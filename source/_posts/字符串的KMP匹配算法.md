---
title: 字符串的KMP匹配算法
date: 2017-02-12 14:35:11
categories: 数据结构
tags:
    - 数据结构
    - 字符串
---

在一个主串长为m，模式串长为n的匹配问题中，采用简单的匹配算法有着O(m * n)的时间复杂度。但是其中存在部分字符重复匹配。如果我们能够有效减少其中的重复匹配的现象，便能够将时间复杂度降低到O(m + n)，这无疑对提高模式匹配的速度十分有效。本文以考研复习时对《数据结构》一书中相关介绍的理解为主，添加一些实例，旨在日后自己忘记能更快回忆起并理解，同时也供路过网友参考。
<!-- more -->

## 普通匹配算法引起的思考
### 普通匹配算法

现在有一个"abcaaba"的字符串（主串），需要在其中查找（匹配）一个"aba"的子串（模式串）第一次出现的位置，那么我们可以想到如下方法：

<center>![p1]</center>

如图，我们发现在第一次匹配时模式串中最后一个字符'a'和主串中对应字符'c'不同，说明不匹配，还需要进行查找。为了不漏过任意一个字串，我们谨慎地将模式串向右移动一位，再次进行匹配：

<center>![p2]</center>

这次似乎更不走运了，第一个字符就不相同。我们需要再将模式串向右移动一个字符，继续匹配，直到：

<center>![p3]</center>

哈，我们终于找到了它出现的位置。不过先别急着休息，我们先来回顾一下我们的方法吧。

在每一次匹配中，我们从模式串的第一个字符起，一个一个地向后比较，直到出现不同的字符或者比较完所有字符。若是比较完所有字符都相等那当然是说明我们找到了模式串的位置，若是出现了不同的字符，那么很遗憾，我们还需要将模式串向右移一位重新比较。

### 对于特殊例子的改进

这个方法比较关键的一点在于，每次匹配失败后就要把模式串右移一位再重新比较。我们来详细研究一下第一次匹配：

<center>![p4]</center>

毫无疑问主串和模式串的前两个字符完全相等，作为智慧生物我们可以一眼就看出来的。接下来我们在这里停住，做一点点小的推导：

>我们设主串的字符分别为S1、S2、...、Sm，模式串的字符则为T1、T2、...、Tn。由第一次匹配我们得到的结果是 S1 = T1、S2 = T2，同时我们观察模式串的前两个字符，很明显可以得到 T1 != T2（此处的 != 为不等于），那么结合一下我们就能得到 T1 != S2。

等等，是不是觉得这个结果有点熟悉。对了，这正是我们第二次匹配的结果！

<center>![p2]</center>

这么说来只要加上简单的判断，我们就能减少许多像这样的匹配了。不过先别急，我们这里遇到的似乎只是一个特殊的情况，要让我们死板的计算机朋友也和我们这样取巧的话我们还需要找出一种更一般的方法。

## KMP匹配算法

### 寻找通用的方法

打个比方说，假如我们有一个表（不妨叫做next表），能告诉计算机在模式串某一位的匹配中失败应该跳过下面的几次匹配，比如我们这个例子中就跳过了一次。或者采用更形象的描述，我们的模式串相对于主串向右多滑动了几个字符。因为按照我们上面的推导，似乎这个表里的数值只和模式串本身有关，那么我们便有信心使用某种算法在匹配之前就将这样的next表给计算出来，一次计算便可以造福后面的所有匹配。

<center>![p1] ![p5]</center>

也就是说，只要我们有了这个next表，后面的匹配过程就能很轻易地实现了，我们就能很轻易地跳过很多次匹配了。我们只需要按照普通的方法那样匹配，唯一不同的在于，如果出现不匹配，我们不是“无脑”地将模式串向右滑动一个字符，而是借助一个next表“机智”地尽可能向右多滑动几个字符，以尽量减少计算机朋友判断的次数。

按照这个思路，我们可以很轻易写出对应的C语言代码：

	// S为主串，T为模式串，pos为从主串的第几位开始匹配
    // 下标都从1开始
	int Index_KMP(SString S, SString T, int pos)
    {
    	// i为主串待匹配的字符位，j为模式串待匹配的字符位
    	int i = pos, j = 1;
        // 下标0存储串的长度
        while (i <= S[0] && j <= T[0])
        {
        	if (j == 0 || S[i] == T[j])
            {
            	++i;
                ++j;
            }
            else
            {
            	// next为参考的表，计算方法在后文
            	j = next[j];
            }
        }
        // 匹配到模式串的最后则说明匹配成功
        if (j > T[0])
        	return i - T[0];
        else
        	return 0;
    }

这段代码是《数据结构》课本中的，有关的数据类型定义也能在书中找到。

现在看来似乎一切都很美好，唯一剩下的问题就是next表的计算了。

### 计算next表


[p1]:http://ol98d2692.bkt.clouddn.com/字符串的KMP匹配算法/1.png "普通第一次匹配"
[p2]:http://ol98d2692.bkt.clouddn.com/字符串的KMP匹配算法/2.png "普通第二次匹配"
[p3]:http://ol98d2692.bkt.clouddn.com/字符串的KMP匹配算法/3.png "普通最后一次匹配"
[p4]:http://ol98d2692.bkt.clouddn.com/字符串的KMP匹配算法/4.png "普通第一次匹配2"
[p5]:http://ol98d2692.bkt.clouddn.com/字符串的KMP匹配算法/5.png "普通第二次匹配2"